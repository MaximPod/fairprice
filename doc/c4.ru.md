# FairPrice App

## C1:Context

 UserStory and и детали в файле Index price test task(user story).pdf  

  Ограничения UserStory:
   - Демо-версия. Версия не предназначена для продакшена  и эксплуатации в облачных системах
   - Курс отслежваемый валюты один BTC-USD
   - Источников данных может быть до 100 шт
   - Данные могут опаздывать
   - Каналы могут закрываться
   - Формата сообщения нет
   - Интенсивность данных из источника не определена
   - Параметры валидации данных не определены
  
  Ограничения от разработчика:   
  Понятие Fair Price, как и методика ее расчета для криптовалют, не имеют однозначного определения. Как я понял, эта задача на сегодня никем в мире не решена.  
  Расчет  Fair Price на основании только данных о курсе не возможен.  

  Предположим, что под Fair Price понимается прогноз курса на следующий интервал.     
  Для расчета прогноза используем аппроксимацию по трем точками. В качестве точек используем средние значения курса. Т.к. значения курса нормально распределены - можно считать средним значением курса среднее арифметическое от полученных данных.


## C2:Container
Входные параметры:
  -  Синхронизации времени между источниками нет
  -  Фьючерсные данные считаются текущими
  -  Опоздавшие данные игнорируются
  -  Источники данных разноформатны и используют разный транспорт
  -  Приложение читает объединенный канал данных. Конкатенация каналов в один - задача для инфраструктуры или отдельных сервисов-сборщиков.

Эмуляция каналов:
   -  Количество каналов 5
   -  Итервал поступления данных - совпадает с интервалом расчета
   -  Данные о курсе считаем валидными

Транспорт:
 - используем библиотеку https://watermill.io/  которая позволяет легко переключаться между транспортами: Go Channel, Kafka, NATS Streaming, Google Pub\sub, ARMQ, SQL
 - работоспособность канала заложена в сахаре либы
 - для демо-приложения используем Go Channel
 - результаты выводим в консоль
  
 
Конфигурация и параметры:
 - для демо-приложения не предустмотрено файлов конфигурации или флагов параметров. Приложение сконфигурировано в коде для демонстрации работы
 - данные для эмуляции прописаны в коде программы

Выходные параметры:
 - результат расчета выводится в лог

## C3:Component

Формат сообщения:
   >type TickerPrice struct {  
	Ticker   Ticker    `json:"ticker"`  - тип курса, например BTC_USD  
	Time     time.Time `json:"time"` -  время курса  
	Price    string    `json:"price"`  - значение курса  
	SourceID int       `json:"source_id" - источник курса  
}

Интервал сбора данных и расчета: в тз 60 сек, в режиме эмуляции можно поднять до 5 сек

Формат вывода:
   > TimeStamp Value,где  
     - TimeStamp - время начала сбора данных в корзину в Unix формате  
     - Value -  значение  FairPrice  рассчитанное по модели
 

## C4:Code
 - код должен содержать комментарии на английском
 - модель расчета вынесена в отдельный интерфейс
 - контрольных тестов нет